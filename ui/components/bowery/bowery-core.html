<!--
Copyright (c) 2014 Bowery, Inc. All rights reserved.
-->

<!--
`bowery-core` is the bowery desktop app

@group Bowery Core Elements
@element bowery-core
-->
<link rel="import" href="bowery-screen.html">
<link rel="import" href="bowery-nav.html">
<link rel="import" href="bowery-apps.html">
<link rel="import" href="bowery-form.html">
<link rel="import" href="bowery-modal.html">
<link rel="import" href="bowery-shell.html">
<link rel="import" href="bowery-analytics.html">
<link rel="import" href="../core-localstorage/core-localstorage.html">
<link rel="import" href="../core-ajax/core-ajax.html">

<polymer-element name="bowery-core" attributes="developer">
<template>
<bowery-analytics id="analytics"></bowery-analytics>
<core-localstorage id="db" name="bowery-developer" value="{{developer}}"></core-localstorage>
<link rel="stylesheet" href="../../bowery/out.css">
<style>
  span, pre {
    color: white;
  }
  :host {
    overflow: hidden;
  }

  .test-modal {
    position: relative;
    background: white;
    height: 45px;
    width: 345px;
    margin-top: 80px;
    margin-left: 9px;
  }
</style>
<bowery-nav type="header">Bowery</bowery-nav>

<bowery-screen path="/login">
  <bowery-form title="login" on-bowery-form-response="{{handleLoginAttempt}}" endpoint="http://broome.io/developers/token" fields="{{loginFields}}" sendAs="json">
    <a href="/signup" on-click="{{navigate}}">I don't have a bowery account.</a>
  </bowery-form>
</bowery-screen>

<bowery-screen path="/signup">
  <bowery-form title="signup" endpoint="http://broome.io/developers" fields="{{signupFields}}" on-bowery-form-response="{{handleSignupAttempt}}" sendAs="json">
    <a href="/login" on-click="{{navigate}}">I already have a bowery account.</a>
  </bowery-form>
</bowery-screen>

<bowery-screen path="/apps">
  <bowery-apps applications="{{applications}}"></bowery-apps>
  <bowery-nav type="footer" href="/apps/new" on-click="{{navigate}}">Create App</bowery-nav>
</bowery-screen>

<bowery-screen path="/apps/status">
  <bowery-shell app="{{app}}" logs="{{app.logs}}" token="{{developer.token}}">
    <a href="/apps" on-click="{{navigate}}">I'm over it. Take me home.</a>
  </bowery-shell>
  <bowery-nav type="footer" href="/apps/edit" on-click="{{navigate}}">Edit App</bowery-nav>
</bowery-screen>

<bowery-screen path="/apps/edit">
  <bowery-form title="Save" endpoint="/applications/{{app._id}}" model="{{app}}" fields="{{editAppFields}}" sendAs="json" on-bowery-form-response="{{handleEditAppAttempt}}" token="{{developer.token}}">
    <a href="/apps/status" on-click="{{navigate}}">Nevermind. Take me back.</a> |
    <a href="" on-click="{{deleteApp}}" class="error">Delete This App</a>
  </bowery-form>
</bowery-screen>

<bowery-screen path="/apps/new">
  <bowery-form title="Provision" endpoint="/applications" fields="{{newAppFields}}" sendAs="json" on-bowery-form-response="{{handleCreateAppAttempt}}" token="{{developer.token}}">
    <a href="/apps" on-click="{{navigate}}">I'm lost. Take me home.</a>
  </bowery-form>
</bowery-screen>
<core-ajax id="ajax" handleAs="json" on-core-response="{{getUserByToken}}" auto></core-ajax>
<core-ajax id="appAjax" handleAs="json" on-core-response="{{getAppById}}" auto></core-ajax>
<core-ajax id="appsAjax" handlAs="json" on-core-response="{{getApps}}" on-core-error="{{logout}}" url="/applications?token={{developer.token}}" auto></core-ajax>
<core-ajax id="deleteAppAjax" method="DELETE" handleAs="json" on-core-response="{{handleDeleteAppAttempt}}" auto></core-ajax>
</template>
<script>
// Utils
var lzwDecode = function (minCodeSize, data) {
	// TODO: Now that the GIF parser is a bit different, maybe this should get an array of bytes instead of a String?
	var pos = 0; // Maybe this streaming thing should be merged with the Stream?
	var readCode = function (size) {
		var code = 0;
		for (var i = 0; i < size; i++) {
			if (data.charCodeAt(pos >> 3) & (1 << (pos & 7))) {
				code |= 1 << i;
			}
			pos++;
		}
		return code;
	};

	var output = [];

	var clearCode = 1 << minCodeSize;
	var eoiCode = clearCode + 1;

	var codeSize = minCodeSize + 1;

	var dict = [];

	var clear = function () {
		dict = [];
		codeSize = minCodeSize + 1;
		for (var i = 0; i < clearCode; i++) {
			dict[i] = [i];
		}
		dict[clearCode] = [];
		dict[eoiCode] = null;

	};

	var code;
	var last;

	while (true) {
		last = code;
		code = readCode(codeSize);

		if (code === clearCode) {
			clear();
			continue;
		}
		if (code === eoiCode) break;

		if (code < dict.length) {
			if (last !== clearCode) {
				dict.push(dict[last].concat(dict[code][0]));
			}
		}
		else {
			if (code !== dict.length) throw new Error('Invalid LZW code.');
			dict.push(dict[last].concat(dict[last][0]));
		}
		output.push.apply(output, dict[code]);

		if (dict.length === (1 << codeSize) && codeSize < 12) {
			// If we're at the last code and codeSize is 12, the next code will be a clearCode, and it'll be 12 bits long.
			codeSize++;
		}
	}

	// I don't know if this is technically an error, but some GIFs do it.
	//if (Math.ceil(pos / 8) !== data.length) throw new Error('Extraneous LZW bytes.');
	return output;
};

//
function GifStream (data) {
  this.data = data
  this.len = this.data.length
  this.pos = 0
  this.comment = ""
}

GifStream.prototype.readByte = function () {
  if (this.pos >= this.data.length) {
    throw new Error('Attempted to read past end of stream')
  }
  return this.data.charCodeAt(this.pos++) & 0xFF
}

GifStream.prototype.readBytes = function (n) {
  var bytes = []
  for (var i = 0; i < n; i++)
    bytes.push(this.readByte())

  return bytes
}

GifStream.prototype.read = function (n) {
  var out = ''
  for (var i = 0; i < n; i++)
    out += String.fromCharCode(this.readByte())

  return out
}

GifStream.prototype.readUnsigned = function () { // Little-endian swag
  var a = this.readBytes(2)
  return (a[1] << 8) + a[0]
}

GifStream.prototype.parseID = function (callback) {
  var st = this
  var result = {}


  var bitsToNum = function (ba) {
    return ba.reduce(function (s, n) {
      return s * 2 + n
    }, 0)
  }

  var byteToBitArr = function (bite) {
    var a = []
    for (var i = 7; i >= 0; i--)
      a.push(!!(bite & (1 << i)))

    return a
  }

  var parseCT = function (entries) {
    var ct = []
    for (var i = 0; i < entries; i++)
      ct.push(st.readBytes(3))
    return ct
  }

  var readSubBlocks = function () {
    var size, data = ""

    do {
      size = st.readByte()
      data += st.read(size)
    } while (size !== 0);

    return data
  }

  var parseHeader = function () {
    var hdr = {}
    hdr.sig = st.read(3)
    hdr.ver = st.read(3)
    if (hdr.sig !== 'GIF') throw new Error('Not a GIF file.')

    hdr.width = st.readUnsigned()
    hdr.height = st.readUnsigned()

    var bits = byteToBitArr(st.readByte())
    hdr.gctFlag = bits.shift()
    hdr.colorRes = bitsToNum(bits.splice(0, 3))
    hdr.sorted = bits.shift()
    hdr.gctSize = bitsToNum(bits.splice(0, 3))

    hdr.bgColor = st.readByte()
    hdr.pixelAspectRatio = st.readByte()
    hdr.pixelAspectRatio = st.readByte()
    if (hdr.gctFlag)
      hdr.gct = parseCT(1 << (hdr.gctSize + 1))
    // return hdr ?
  }

  var parseExt = function (block) {
    var parseGCExt = function (block) {
      var blockSize = st.readByte()
      var bits = byteToBitArr(st.readByte())
      block.reserved = bits.splice(0, 3)
      block.disposalMethod = bitsToNum(bits.splice(0, 3));
      block.userInput = bits.shift();
      block.transparencyGiven = bits.shift();

      block.delayTime = st.readUnsigned();

      block.transparencyIndex = st.readByte();

      block.terminator = st.readByte();
      // return block ?
    }


    // The only thing that matters in this whole function
    var parseComExt = function (block) {
      block.comment = readSubBlocks()
      // console.log('parseComExt', block)
      callback && callback(block)
      // return block ?
    }

    var parsePTExt = function (block) {
      // No one *ever* uses this. If you use it, deal with parsing it yourself.
      var blockSize = st.readByte(); // Always 12
      block.ptHeader = st.readBytes(12);
      block.ptData = readSubBlocks();
      // return block ?
    }

    var parseAppExt = function (block) {
      var parseNetscapeExt = function (block) { // ya, netscape. It's 1993.
        var blockSize = st.readByte();
        block.unkown = st.readByte();
        block.iterations = st.readUnsigned()
        block.terminator = st.readByte();
        // return block ?
      }

      var parseUnkownAppExt = function (block) {
        block.appData = readSubBlocks()
        // return block ?
      }

      var blockSize = st.readByte()
      block.identifier = st.read(8)
      block.authCode = st.read(3)
      switch (block.identifier) {
        case 'NETSCAPE':
          parseNetscapeExt(block);
          break;
        default:
          parseUnkownAppExt(block);
          break;
      }
    }

    var parseUnkownExt = function (block) {
      block.data = readSubBlocks()
      // return block?
    }

    block.label = st.readByte()
    switch (block.label) {
      case 0xF9:
        block.extType = 'gce';
        parseGCExt(block);
        break;
      case 0xFE:
        block.extType = 'com';
        parseComExt(block);
        break;
      case 0x01:
        block.extType = 'pte';
        parsePTExt(block);
        break;
      case 0xFF:
        block.extType = 'app';
        parseAppExt(block);
        break;
      default:
        block.extType = 'unknown';
        parseUnknownExt(block);
        break;
    }

  }

  var parseImg = function (img) {
    var deinterlace = function (pixels, width) {
      var newPixels = new Array(pixels.length)
      var rows = pixels.length / width
      var cpRow = function (toRow, fromRow) {
        var fromPixels = pixels.slice(fromRow * width, (fromRow + 1) * width)
        newPixels.splice.apply(newPixels, [toRow * width, width].concat(fromPixels))
      }

      // James Dean Says So
      var offsets = [0, 4, 2, 1]
      var steps = [8, 8, 4, 2]

      var fromRow = 0
      for (var pass = 0; pass < 4; pass++) {
        for (var toRow = offsets[pass]; toRow < rows; toRow += steps[pass]) {
          cpRow(toRow, fromRow)
          fromRow++
        }
      }
      return newPixels
    }

    img.leftPos = st.readUnsigned()
    img.topPos = st.readUnsigned()
    img.width = st.readUnsigned()
    img.height = st.readUnsigned()

    var bits = byteToBitArr(st.readByte())
    img.lctFlag = bits.shift()
    img.interlaced = bits.shift()
    img.sorted = bits.shift()
    img.reserved = bits.splice(0, 2)
    img.lctSize = bitsToNum(bits.splice(0, 3))

    if (img.lctFlag) {
      img.lct = parseCT(1 << (img.lctSize + 1))
    }

    img.lzwMinCodeSize = st.readByte()
    var lzwData = readSubBlocks()

    img.pixels = lzwDecode(img.lzwMinCodeSize, lzwData)

    if (img.interlaced) {
      img.pixels = deinterlace(img.pixels, img.width)
    }
    // return img?
  }

  var parseBlock = function () {
    var block = {}
    block.sentinel = st.readByte()

    switch (String.fromCharCode(block.sentinel)) {
      case '!':
        block.type = 'ext';
        parseExt(block);
        break;
      case ',':
        block.type = 'img';
        parseImg(block);
        break;
      case ';':
        block.type = 'eof';
        break;
      default:
        // console.log('unkown block: 0x' + block.sentinel.toString(16))
        break;
    }

    if (block.type !== 'eof') {
      // return parseBlock()
      setTimeout(parseBlock, 0) // wow, I can't believe I just wrote that
    }
  }

  var parse = function () {
    parseHeader()
    // return parseBlock()
    setTimeout(parseBlock, 0);
  }
  parse();
},


Polymer('bowery-core', {
  created: function () {
    // The current app being shown
    this.app = {}

    // All of the current users application
    this.applications = []

    // The current user
    this.developer = {}
  },
  loginFields: [
    {name: 'email'},
    {name: 'password', type: 'password'}
  ],
  signupFields: [
    {name: 'name'},
    {name: 'email'},
    {name: 'password', type: 'password'}
  ],
  editAppFields: [
    {name: 'name'},
    {name: 'start'},
    {name: 'build'},
    {name: 'remotePath', label: 'Remote Path'},
    {name: 'localPath', label: 'Local Path'}
  ],
  newAppFields: [
    {name: 'aws_access_key', label: 'AWS Key'},
    {name: 'aws_secret_key', label: 'AWS Secret'},
    {name: 'envID', label: 'Environment'},
    {name: 'instance_type', label: 'Size', type: 'pill', options: ["m1.small", "m1.medium", "m1.large"]}
  ],
  ready: function () {
    this.$.analytics.track("Opened App")
    window.addEventListener('bowery-navigate', this.onNavigate.bind(this))

    // Drag & Drop Swag
    window.addEventListener('dragenter', function (e) {
      e.stopPropagation()
      e.preventDefault()
    })
    window.addEventListener('dragover', function (e) {
      e.stopPropagation()
      e.preventDefault()
    })
    window.addEventListener('drop', this.createAppFromDroppedImage)

    this.$.db.load()
    this.developer = this.$.db.value || {}

    var sse = new EventSource('/_/sse')
    sse.addEventListener('message', this.handleSSE.bind(this))

    if (!this.developer.token) {
      return this.navigate('/login')
    }

    this.newAppFields[0].value = this.developer.aws_access_key
    this.newAppFields[1].value = this.developer.aws_access_secret

    this.navigate('/apps')
  },
  createAppFromDroppedImage: function (e) {
    e.preventDefault()
    var file = e.dataTransfer.files[0];
    if (file.type != "image/gif") {
      return alert("File must be a gif, not " + file.type)
    }
    var self = this
    var reader = new FileReader();
    reader.onload = function (evt) {
      var text = evt.target.result
      // var data = new ArrayBuffer(text.length)
      // var ui8a = new Uint8Array(data, 0)
      // for (var i = 0; i < text.length; i++)
      //   ui8a[i] = (text.charCodeAt(i) & 0xff)

      // TODO (thebyrd) Get Comment Extension
      var stream = new GifStream(text)
      var called = false
      stream.parseID(function (comExt) {
        if (!called)
          console.log('$$$$ ID', comExt.comment)
        called = true
      })
      // TODO (thebyrd) Navigate to Create App Page w/ the environment ID already set

    }
    reader.readAsBinaryString(file)
  },
  handleSSE: function (e) {
    var event = JSON.parse(e.data)

    if (event.type == 'status')
      for (var i = 0, app; app = this.applications[i]; i++)
        if (app._id == event.appID)
          return (this.applications[i].status = event.message.status)

    if (event.type == 'log')
      if (this.app._id == event.appID)
        this.app.logs += event.message

  },
  handleCreateAppAttempt: function (e) {
    var response = e.target.response
    if (response.status != 'success') {
      if (response.error == "EOF") return

      this.$.analytics.track("Failed to Create App", {error: response.error})
      e.target.feedback = response.error
      return
    }
    this.app = response.application
    this.applications.push(this.app)
    for (var i = 0, field; field = this.editAppFields[i]; i++)
      field.value = this.app[field.name]

    var key = e.detail.fields[0].value
    var secret = e.detail.fields[1].value

    this.developer.aws_access_key = key
    this.developer.aws_access_secret = secret

    this.navigate('/apps/edit')
  },
  handleEditAppAttempt: function (e, detail) {
    var response = e.target.response
    if (response.status != 'success') {
      if (response.error == "EOF") return

      this.$.analytics.track("Failed to Edit App", {error: response.error})
      e.target.feedback = response.error
      return
    }

    this.app = detail.model
    for (var i = 0, app; app = this.applications[i]; i++)
      if (app._id == this.app._id)
        this.applications[i] = this.app

    this.navigate('/apps')
  },
  handleLoginAttempt: function (e) {
    var response = e.target.response
    if (response.status != "created") {
      if (response.error == "EOF") return

      this.$.analytics.track("Failed Login Attempt", {error: response.error})
      e.target.feedback = response.error
      return
    }
    this.developer = {}
    this.developer.token = response.token
    this.$.ajax.url = "http://broome.io/developers/me?token=" + this.developer.token

    this.navigate('/apps')
  },
  getUserByToken: function (e) {
    var response = e.target.response
    if (response.status == "found") {
      this.developer = response.developer
      this.developer['$email'] = this.developer.email // bullshit => https://mixpanel.com/docs/properties-or-segments/special-or-reserved-properties
      this.$.analytics.register(this.developer)
    }
  },
  handleSignupAttempt: function (e) {
    var response = e.target.response
    if (response.status == "created") {
      this.developer = response.developer
      this.$.db.save()
      return this.navigate('/apps')
    }

    if (response.error == "EOF")
      return

    this.$.analytics.track("Failed Signup Attempt", {error: response.error})
    e.target.feedback = response.error
  },
  parameterize: function (obj) {
    var out = ""
    for (var key in obj) {
      out += key + "=" + obj[key] + "&"
    }
    return out
  },
  deleteApp: function (e) {
    e.preventDefault()
    var tokens = {
      token: this.developer.token,
      aws_access_key: this.developer.aws_access_key,
      aws_secret_key: this.developer.aws_access_secret
    }
    this.$.deleteAppAjax.url = "/applications/" + this.app._id + "?" + this.parameterize(tokens)
    this.$.appsAjax.params = {cachebuster: Date.now()}
  },
  getApps: function (e, detail) {
    var r = JSON.parse(detail.response)
    if (r.status == "found")
      this.applications = r.applications
    else
      this.logout()
  },
  handleDeleteAppAttempt: function (e) {
    var response = e.target.response
    if (response.status == 'success') {

      this.applications = this.applications.filter(function (app) {
        return app._id != response.id
      })

      return this.navigate('/apps')
    }
    alert('unable to delete ')
  },
  navigate: function (path) {
    if (typeof path != "string") {
      var e = path
      e.preventDefault()
      path = e.target.getAttribute('href')
    }
    this.$.analytics.track('Navigated to ' + path)

    this.fire('bowery-navigate', {path: path})
  },
  logout: function () {
    this.developer = {}
    this.$.db.save()
    this.navigate('/login')
  },

  /**
   * A hack for passing params between screens.
   * TODO (thebyrd) replace with something that's easier to debug
   */
  onNavigate: function (e) {
    if (e.detail.app)
      this.$.appAjax.url = '/applications/' + e.detail.app
  },
  getAppById: function (e) {
    var response = e.target.response
    if (response.status == 'found') {
      this.app = response.application
    }
  }
})
</script>
</polymer-element>
